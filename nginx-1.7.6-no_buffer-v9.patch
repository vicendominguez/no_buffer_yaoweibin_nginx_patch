diff -ru nginx-1.7.6/src/http/modules/ngx_http_fastcgi_module.c nginx-1.7.6vd/src/http/modules/ngx_http_fastcgi_module.c
--- nginx-1.7.6/src/http/modules/ngx_http_fastcgi_module.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/modules/ngx_http_fastcgi_module.c	2014-10-02 18:31:53.000000000 +0200
@@ -66,8 +66,10 @@
     u_char                        *last;
     ngx_uint_t                     type;
     size_t                         length;
+    size_t                         output_padding;
     size_t                         padding;
 
+    unsigned                       output_done:1;
     unsigned                       fastcgi_stdout:1;
     unsigned                       large_stderr:1;
 
@@ -135,6 +137,8 @@
 static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r);
 static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r);
 static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r);
+static ngx_int_t ngx_http_fastcgi_output_filter_init(void *data);
+static ngx_int_t ngx_http_fastcgi_output_filter(void *data, ngx_chain_t *in);
 static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data);
 static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p,
     ngx_buf_t *buf);
@@ -242,6 +246,13 @@
       offsetof(ngx_http_fastcgi_loc_conf_t, upstream.buffering),
       NULL },
 
+    { ngx_string("fastcgi_request_buffering"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, upstream.request_buffering),
+      NULL },
+
     { ngx_string("fastcgi_ignore_client_abort"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -646,6 +657,17 @@
     u->finalize_request = ngx_http_fastcgi_finalize_request;
     r->state = 0;
 
+    r->request_buffering = flcf->upstream.request_buffering;
+    if (r->headers_in.content_length_n <= 0 && !r->headers_in.chunked) {
+        r->request_buffering = 1;
+    }
+
+    if (!r->request_buffering) {
+        u->output_filter_init = ngx_http_fastcgi_output_filter_init;
+        u->output_filter = ngx_http_fastcgi_output_filter;
+        u->output_filter_ctx = r;
+    }
+
     u->buffering = flcf->upstream.buffering;
 
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
@@ -1084,8 +1106,14 @@
     h->padding_length = 0;
     h->reserved = 0;
 
-    h = (ngx_http_fastcgi_header_t *) b->last;
-    b->last += sizeof(ngx_http_fastcgi_header_t);
+    /*
+     * Don't send the last FASTCGI_STDIN record, It will be sent in the
+     * output filter
+     */
+    if (r->request_buffering) {
+        h = (ngx_http_fastcgi_header_t *) b->last;
+        b->last += sizeof(ngx_http_fastcgi_header_t);
+    }
 
     if (flcf->upstream.pass_request_body) {
         body = r->upstream->request_bufs;
@@ -1193,14 +1221,16 @@
         r->upstream->request_bufs = cl;
     }
 
-    h->version = 1;
-    h->type = NGX_HTTP_FASTCGI_STDIN;
-    h->request_id_hi = 0;
-    h->request_id_lo = 1;
-    h->content_length_hi = 0;
-    h->content_length_lo = 0;
-    h->padding_length = 0;
-    h->reserved = 0;
+    if (r->request_buffering) {
+        h->version = 1;
+        h->type = NGX_HTTP_FASTCGI_STDIN;
+        h->request_id_hi = 0;
+        h->request_id_lo = 1;
+        h->content_length_hi = 0;
+        h->content_length_lo = 0;
+        h->padding_length = 0;
+        h->reserved = 0;
+    }
 
     cl->next = NULL;
 
@@ -1234,6 +1264,203 @@
 
 
 static ngx_int_t
+ngx_http_fastcgi_output_filter_init(void *data)
+{
+    ngx_http_request_t      *r = data;
+
+    /*
+     * Remove the r->request_body from request_bufs.
+     * This part buffer will be processed in the output filter.
+     */
+    r->upstream->request_bufs = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_fastcgi_output_filter(void *data, ngx_chain_t *in)
+{
+    size_t                     len, padding;
+    ngx_buf_t                 *b;
+    ngx_uint_t                 split, last;
+    ngx_chain_t              **last_out, *cl;
+    ngx_http_request_t        *r = data;
+    ngx_http_fastcgi_ctx_t    *f;
+    ngx_http_request_body_t   *rb;
+    ngx_http_fastcgi_header_t *h;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http fastcgi output filter");
+
+    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);
+    rb = r->request_body;
+    last = 0;
+
+    if (r->upstream->request_bufs == NULL) {
+        last_out = &r->upstream->request_bufs;
+    } else {
+        cl = r->upstream->request_bufs;
+
+        while (cl->next) {
+            cl = cl->next;
+        }
+
+        last_out = &cl->next;
+    }
+
+    if (in == NULL) {
+
+        if (!f->output_done && rb->rest == 0) {
+            goto last_chunk;
+        }
+
+        return NGX_OK;
+    }
+
+    while (in) {
+
+        split = 0;
+
+        if (in->buf->last_buf) {
+            in->buf->last_buf = 0;
+            last = 1;
+        }
+
+        len = ngx_buf_size(in->buf);
+        if (len == 0) {
+            in = in->next;
+            continue;
+        }
+
+        /*
+         * limit the output buffer to be 32k, fastcgi record can't be
+         * larger than 64k.
+         */
+        if (len > 32768) {
+            split = 1;
+            len = 32768;
+        }
+
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        *last_out = cl;
+        last_out = &cl->next;
+
+        /* TODO: recycle buffer */
+        b = ngx_create_temp_buf(r->pool,
+                sizeof(ngx_http_fastcgi_header_t) + f->output_padding);
+        if (b == NULL) {
+            return NGX_ERROR;
+        }
+
+        cl->buf = b;
+
+        if (f->output_padding) {
+            ngx_memzero(b->last, f->output_padding);
+            b->last += f->output_padding;
+            f->output_padding = 0;
+        }
+
+        h = (ngx_http_fastcgi_header_t *) b->last;
+        b->last += sizeof(ngx_http_fastcgi_header_t);
+
+        padding = 8 - len % 8;
+        padding = (padding == 8) ? 0 : padding;
+
+        h->version = 1;
+        h->type = NGX_HTTP_FASTCGI_STDIN;
+        h->request_id_hi = 0;
+        h->request_id_lo = 1;
+        h->content_length_hi = (u_char) ((len >> 8) & 0xff);
+        h->content_length_lo = (u_char) (len & 0xff);
+        h->padding_length = (u_char) padding;
+        h->reserved = 0;
+
+        f->output_padding = padding;
+
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        *last_out = cl;
+        last_out = &cl->next;
+
+        if (!split) {
+            cl->buf = in->buf;
+        } else {
+            b = ngx_calloc_buf(r->pool);
+            if (b == NULL) {
+                return NGX_ERROR;
+            }
+
+            cl->buf = b;
+
+            b->temporary = 1;
+            b->start = b->pos = in->buf->pos;
+            b->end = b->last = in->buf->pos + len;
+
+            in->buf->pos = in->buf->pos + len;
+
+            continue;
+        }
+
+        in = in->next;
+    }
+
+    if (rb->rest) {
+        *last_out = NULL;
+        return NGX_OK;
+    }
+
+last_chunk:
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_ERROR;
+    }
+
+    *last_out = cl;
+
+    b = ngx_create_temp_buf(r->pool, sizeof(ngx_http_fastcgi_header_t)
+                                     + f->output_padding);
+    if (b == NULL) {
+        return NGX_ERROR;
+    }
+
+    if (f->output_padding) {
+        ngx_memzero(b->last, f->output_padding);
+        b->last += f->output_padding;
+        f->output_padding = 0;
+    }
+
+    h = (ngx_http_fastcgi_header_t *) b->last;
+    b->last += sizeof(ngx_http_fastcgi_header_t);
+    b->last_buf = last;
+
+    h->version = 1;
+    h->type = NGX_HTTP_FASTCGI_STDIN;
+    h->request_id_hi = 0;
+    h->request_id_lo = 1;
+    h->content_length_hi = 0;
+    h->content_length_lo = 0;
+    h->padding_length = 0;
+    h->reserved = 0;
+
+    cl->buf = b;
+    cl->next = NULL;
+
+    f->output_done = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
 ngx_http_fastcgi_process_header(ngx_http_request_t *r)
 {
     u_char                         *p, *msg, *start, *last,
@@ -2330,6 +2557,7 @@
     conf->upstream.store = NGX_CONF_UNSET;
     conf->upstream.store_access = NGX_CONF_UNSET_UINT;
     conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
+    conf->upstream.request_buffering = NGX_CONF_UNSET;
     conf->upstream.buffering = NGX_CONF_UNSET;
     conf->upstream.ignore_client_abort = NGX_CONF_UNSET;
 
@@ -2407,6 +2635,9 @@
     ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
                               prev->upstream.next_upstream_tries, 0);
 
+    ngx_conf_merge_value(conf->upstream.request_buffering,
+                              prev->upstream.request_buffering, 1);
+
     ngx_conf_merge_value(conf->upstream.buffering,
                               prev->upstream.buffering, 1);
 
Only in nginx-1.7.6vd/src/http/modules: ngx_http_fastcgi_module.c.orig
diff -ru nginx-1.7.6/src/http/modules/ngx_http_proxy_module.c nginx-1.7.6vd/src/http/modules/ngx_http_proxy_module.c
--- nginx-1.7.6/src/http/modules/ngx_http_proxy_module.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/modules/ngx_http_proxy_module.c	2014-10-02 18:30:06.000000000 +0200
@@ -107,6 +107,8 @@
 static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r);
 static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r);
 static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r);
+static ngx_int_t ngx_http_proxy_output_filter_init(void *data);
+static ngx_int_t ngx_http_proxy_output_filter(void *data, ngx_chain_t *in);
 static ngx_int_t ngx_http_proxy_input_filter_init(void *data);
 static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p,
     ngx_buf_t *buf);
@@ -263,6 +265,13 @@
       offsetof(ngx_http_proxy_loc_conf_t, upstream.store_access),
       NULL },
 
+    { ngx_string("proxy_request_buffering"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.request_buffering),
+      NULL },
+
     { ngx_string("proxy_buffering"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -787,6 +796,17 @@
         u->rewrite_cookie = ngx_http_proxy_rewrite_cookie;
     }
 
+    r->request_buffering = plcf->upstream.request_buffering;
+    if (r->headers_in.content_length_n <= 0 && !r->headers_in.chunked) {
+        r->request_buffering = 1;
+    }
+
+    if (!r->request_buffering) {
+        u->output_filter_init = ngx_http_proxy_output_filter_init;
+        u->output_filter = ngx_http_proxy_output_filter;
+        u->output_filter_ctx = r;
+    }
+
     u->buffering = plcf->upstream.buffering;
 
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
@@ -1373,6 +1393,47 @@
 
 
 static ngx_int_t
+ngx_http_proxy_output_filter_init(void *data)
+{
+    ngx_http_request_t  *r = data;
+
+    r->upstream->request_bufs = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_proxy_output_filter(void *data, ngx_chain_t *in)
+{
+    ngx_chain_t         *cl, *out;
+    ngx_http_request_t  *r = data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http proxy output filter");
+
+
+    if (ngx_http_chunked_output_filter(r, in, &out) != NGX_OK) {
+        return NGX_OK;
+    }
+
+    if (r->upstream->request_bufs == NULL) {
+        r->upstream->request_bufs = out;
+    } else {
+        cl = r->upstream->request_bufs;
+
+        while (cl->next) {
+            cl = cl->next;
+        }
+
+        cl->next = out;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
 ngx_http_proxy_process_status_line(ngx_http_request_t *r)
 {
     size_t                 len;
@@ -2470,6 +2531,7 @@
     conf->upstream.store = NGX_CONF_UNSET;
     conf->upstream.store_access = NGX_CONF_UNSET_UINT;
     conf->upstream.next_upstream_tries = NGX_CONF_UNSET_UINT;
+    conf->upstream.request_buffering = NGX_CONF_UNSET;
     conf->upstream.buffering = NGX_CONF_UNSET;
     conf->upstream.ignore_client_abort = NGX_CONF_UNSET;
 
@@ -2562,6 +2624,10 @@
     ngx_conf_merge_uint_value(conf->upstream.next_upstream_tries,
                               prev->upstream.next_upstream_tries, 0);
 
+    ngx_conf_merge_value(conf->upstream.request_buffering,
+                              prev->upstream.request_buffering, 1);
+
+
     ngx_conf_merge_value(conf->upstream.buffering,
                               prev->upstream.buffering, 1);
 
Only in nginx-1.7.6vd/src/http/modules: ngx_http_proxy_module.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http.h nginx-1.7.6vd/src/http/ngx_http.h
--- nginx-1.7.6/src/http/ngx_http.h	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http.h	2014-10-02 17:45:48.000000000 +0200
@@ -113,6 +113,8 @@
     ngx_str_t *args);
 ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r, ngx_buf_t *b,
     ngx_http_chunked_t *ctx);
+ngx_int_t ngx_http_chunked_output_filter(ngx_http_request_t *r,
+    ngx_chain_t *in, ngx_chain_t **output);
 
 
 ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c);
@@ -142,6 +144,8 @@
 
 ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r,
     ngx_http_client_body_handler_pt post_handler);
+ngx_int_t ngx_http_do_read_non_buffered_client_request_body(
+    ngx_http_request_t *r);
 
 ngx_int_t ngx_http_send_header(ngx_http_request_t *r);
 ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r,
Only in nginx-1.7.6vd/src/http: ngx_http.h.orig
diff -ru nginx-1.7.6/src/http/ngx_http_core_module.c nginx-1.7.6vd/src/http/ngx_http_core_module.c
--- nginx-1.7.6/src/http/ngx_http_core_module.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_core_module.c	2014-10-02 17:45:48.000000000 +0200
@@ -380,6 +380,20 @@
       offsetof(ngx_http_core_loc_conf_t, client_body_buffer_size),
       NULL },
 
+    { ngx_string("client_body_buffers"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,
+      ngx_conf_set_bufs_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, client_body_buffers),
+      NULL },
+
+    { ngx_string("client_body_postpone_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, client_body_postpone_size),
+      NULL },
+
     { ngx_string("client_body_timeout"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_msec_slot,
@@ -3615,6 +3629,7 @@
      *     clcf->error_log = NULL;
      *     clcf->error_pages = NULL;
      *     clcf->try_files = NULL;
+     *     clcf->client_body_buffers = { 0, 0 };
      *     clcf->client_body_path = NULL;
      *     clcf->regex = NULL;
      *     clcf->exact_match = 0;
@@ -3626,6 +3641,7 @@
 
     clcf->client_max_body_size = NGX_CONF_UNSET;
     clcf->client_body_buffer_size = NGX_CONF_UNSET_SIZE;
+    clcf->client_body_postpone_size = NGX_CONF_UNSET_SIZE;
     clcf->client_body_timeout = NGX_CONF_UNSET_MSEC;
     clcf->satisfy = NGX_CONF_UNSET_UINT;
     clcf->if_modified_since = NGX_CONF_UNSET_UINT;
@@ -3831,6 +3847,27 @@
     ngx_conf_merge_size_value(conf->client_body_buffer_size,
                               prev->client_body_buffer_size,
                               (size_t) 2 * ngx_pagesize);
+    ngx_conf_merge_bufs_value(conf->client_body_buffers,
+                              prev->client_body_buffers,
+                              16, ngx_pagesize);
+
+    if (conf->client_body_buffers.num < 2) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "there must be at least 2 \"client_body_buffers\"");
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_size_value(conf->client_body_postpone_size,
+                              prev->client_body_postpone_size,
+                              64 * 1024);
+
+    if (conf->client_body_postpone_size >
+        (conf->client_body_buffers.num * conf->client_body_buffers.size)) {
+
+        conf->client_body_buffers.num = 1 + (conf->client_body_postpone_size /
+                                             conf->client_body_buffers.size);
+    }
+
     ngx_conf_merge_msec_value(conf->client_body_timeout,
                               prev->client_body_timeout, 60000);
 
Only in nginx-1.7.6vd/src/http: ngx_http_core_module.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http_core_module.h nginx-1.7.6vd/src/http/ngx_http_core_module.h
--- nginx-1.7.6/src/http/ngx_http_core_module.h	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_core_module.h	2014-10-02 17:45:48.000000000 +0200
@@ -365,6 +365,8 @@
     off_t         directio;                /* directio */
     off_t         directio_alignment;      /* directio_alignment */
 
+    ngx_bufs_t    client_body_buffers;
+    size_t        client_body_postpone_size;
     size_t        client_body_buffer_size; /* client_body_buffer_size */
     size_t        send_lowat;              /* send_lowat */
     size_t        postpone_output;         /* postpone_output */
Only in nginx-1.7.6vd/src/http: ngx_http_core_module.h.orig
diff -ru nginx-1.7.6/src/http/ngx_http_parse.c nginx-1.7.6vd/src/http/ngx_http_parse.c
--- nginx-1.7.6/src/http/ngx_http_parse.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_parse.c	2014-10-02 17:45:48.000000000 +0200
@@ -2357,3 +2357,133 @@
 
     return NGX_ERROR;
 }
+
+
+/* TODO: buffer recycle */
+ngx_int_t
+ngx_http_chunked_output_filter(ngx_http_request_t *r,
+    ngx_chain_t *in, ngx_chain_t **output)
+{
+    off_t        size;
+    ngx_buf_t   *b;
+    ngx_chain_t *out, *cl, *tl, **ll;
+
+    if (in == NULL || !r->headers_in.chunked) {
+        *output = in;
+        return NGX_OK;
+    }
+
+    out = NULL;
+    ll = &out;
+
+    size = 0;
+    cl = in;
+
+    for ( ;; ) {
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "http output chunk: %d", ngx_buf_size(cl->buf));
+
+        size += ngx_buf_size(cl->buf);
+
+        if (cl->buf->flush
+            || cl->buf->sync
+            || ngx_buf_size(cl->buf) > 0)
+        {
+            tl = ngx_alloc_chain_link(r->pool);
+            if (tl == NULL) {
+                return NGX_ERROR;
+            }
+
+            tl->buf = cl->buf;
+            *ll = tl;
+            ll = &tl->next;
+        }
+
+        if (cl->next == NULL) {
+            break;
+        }
+
+        cl = cl->next;
+    }
+
+    if (size) {
+        tl = ngx_alloc_chain_link(r->pool);
+        if (tl == NULL) {
+            return NGX_ERROR;
+        }
+
+        /* the "0000000000000000" is 64-bit hexadecimal string */
+        b = ngx_create_temp_buf(r->pool, sizeof("0000000000000000" CRLF) - 1);
+        if (b == NULL) {
+            return NGX_ERROR;
+        }
+
+        b->tag = (ngx_buf_tag_t) &ngx_http_chunked_output_filter;
+        b->last = ngx_sprintf(b->pos, "%xO" CRLF, size);
+
+        tl->buf = b;
+        tl->next = out;
+        out = tl;
+    }
+
+    if (cl->buf->last_buf) {
+        tl = ngx_alloc_chain_link(r->pool);
+        if (tl == NULL) {
+            return NGX_ERROR;
+        }
+
+        /* TODO: buffer recycle */
+        b = ngx_calloc_buf(r->pool);
+        if (b == NULL) {
+            return NGX_ERROR;
+        }
+
+        b->tag = (ngx_buf_tag_t) &ngx_http_chunked_output_filter;
+        b->memory = 0;
+        b->temporary = 1;
+        b->last_buf = 1;
+        b->start = b->pos = (u_char *) CRLF "0" CRLF CRLF;
+        b->end = b->last = b->pos + 7;
+
+        cl->buf->last_buf = 0;
+
+        tl->next = NULL;
+        tl->buf = b;
+        *ll = tl;
+
+        if (size == 0) {
+            b->pos += 2;
+        }
+
+    } else if (size > 0) {
+        tl = ngx_alloc_chain_link(r->pool);
+        if (tl == NULL) {
+            return NGX_ERROR;
+        }
+
+        /* TODO: buffer recycle */
+        b = ngx_calloc_buf(r->pool);
+        if (b == NULL) {
+            return NGX_ERROR;
+        }
+
+        b->tag = (ngx_buf_tag_t) &ngx_http_chunked_output_filter;
+        b->temporary = 0;
+        b->memory = 1;
+        b->start = b->pos = (u_char *) CRLF;
+        b->end = b->last = b->pos + 2;
+
+        tl->next = NULL;
+        tl->buf = b;
+        *ll = tl;
+
+    } else {
+        *ll = NULL;
+    }
+
+    *output = out;
+
+    return NGX_OK;
+}
+
+
Only in nginx-1.7.6vd/src/http: ngx_http_parse.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http_request.c nginx-1.7.6vd/src/http/ngx_http_request.c
--- nginx-1.7.6/src/http/ngx_http_request.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_request.c	2014-10-02 17:45:48.000000000 +0200
@@ -586,6 +586,8 @@
     r->method = NGX_HTTP_UNKNOWN;
     r->http_version = NGX_HTTP_VERSION_10;
 
+    r->request_buffering = 1;
+
     r->headers_in.content_length_n = -1;
     r->headers_in.keep_alive_n = -1;
     r->headers_out.content_length_n = -1;
Only in nginx-1.7.6vd/src/http: ngx_http_request.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http_request.h nginx-1.7.6vd/src/http/ngx_http_request.h
--- nginx-1.7.6/src/http/ngx_http_request.h	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_request.h	2014-10-02 17:45:48.000000000 +0200
@@ -278,6 +278,19 @@
 typedef void (*ngx_http_client_body_handler_pt)(ngx_http_request_t *r);
 
 typedef struct {
+    ngx_chain_t                      *bufs;
+    ngx_buf_t                        *buf;
+    ngx_chain_t                      *busy;
+    ngx_chain_t                      *free;
+    ngx_chain_t                     **last_out;
+    off_t                             postpone_size;
+    ngx_int_t                         num;
+    unsigned                          buffered:1;
+    unsigned                          flush:1;
+    unsigned                          nomem:1;
+} ngx_http_request_body_non_buffered_t;
+
+typedef struct {
     ngx_temp_file_t                  *temp_file;
     ngx_chain_t                      *bufs;
     ngx_buf_t                        *buf;
@@ -286,6 +299,8 @@
     ngx_chain_t                      *busy;
     ngx_http_chunked_t               *chunked;
     ngx_http_client_body_handler_pt   post_handler;
+
+    ngx_http_request_body_non_buffered_t *non_buffered;
 } ngx_http_request_body_t;
 
 
@@ -467,6 +482,7 @@
     unsigned                          uri_changed:1;
     unsigned                          uri_changes:4;
 
+    unsigned                          request_buffering:1;
     unsigned                          request_body_in_single_buf:1;
     unsigned                          request_body_in_file_only:1;
     unsigned                          request_body_in_persistent_file:1;
Only in nginx-1.7.6vd/src/http: ngx_http_request.h.orig
diff -ru nginx-1.7.6/src/http/ngx_http_request_body.c nginx-1.7.6vd/src/http/ngx_http_request_body.c
--- nginx-1.7.6/src/http/ngx_http_request_body.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_request_body.c	2014-10-02 17:45:48.000000000 +0200
@@ -13,6 +13,12 @@
 static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r);
 static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r);
 static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r);
+static ngx_int_t ngx_http_copy_non_buffered_request_body(ngx_http_request_t *r);
+static ngx_int_t ngx_http_read_non_buffered_client_request_body(
+    ngx_http_request_t *r);
+static void ngx_http_read_non_buffered_client_request_body_handler(
+    ngx_http_request_t *r);
+static ngx_int_t ngx_http_request_body_get_buf(ngx_http_request_t *r);
 static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r);
 static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r,
     ngx_buf_t *b);
@@ -85,6 +91,10 @@
         return NGX_OK;
     }
 
+    if (!r->request_buffering) {
+        return ngx_http_read_non_buffered_client_request_body(r);
+    }
+
     preread = r->header_in->last - r->header_in->pos;
 
     if (preread) {
@@ -488,6 +498,509 @@
 }
 
 
+static ngx_int_t
+ngx_http_read_non_buffered_client_request_body(ngx_http_request_t *r)
+{
+    size_t                                 size;
+    size_t                                 preread;
+    ngx_int_t                              rc;
+    ngx_chain_t                            out;
+    ngx_http_request_body_t               *rb;
+    ngx_http_core_loc_conf_t              *clcf;
+    ngx_http_request_body_non_buffered_t  *nb;
+
+    rb = r->request_body;
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    nb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_non_buffered_t));
+    if (nb == NULL) {
+        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        goto done;
+    }
+
+    rb->non_buffered = nb;
+    nb->last_out = &nb->bufs;
+
+    preread = r->header_in->last - r->header_in->pos;
+
+    if (preread) {
+
+        /* there is the pre-read part of the request body */
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "http client no buffered request body preread %uz",
+                       preread);
+
+        out.buf = r->header_in;
+        out.next = NULL;
+
+        rc = ngx_http_request_body_filter(r, &out);
+
+        if (rc != NGX_OK) {
+            goto done;
+        }
+
+        r->request_length += preread - (r->header_in->last - r->header_in->pos);
+
+        if (!r->headers_in.chunked
+            && rb->rest > 0
+            && rb->rest <= (off_t) (r->header_in->end - r->header_in->last))
+        {
+            /* the whole request body may be placed in r->header_in */
+
+            rb->buf = r->header_in;
+            r->read_event_handler =
+                ngx_http_read_non_buffered_client_request_body_handler;
+            r->write_event_handler = ngx_http_request_empty_handler;
+
+            rc = ngx_http_do_read_non_buffered_client_request_body(r);
+            goto done;
+        }
+
+    } else {
+        /* set rb->rest */
+
+        if (ngx_http_request_body_filter(r, NULL) != NGX_OK) {
+            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+            goto done;
+        }
+    }
+
+    if (rb->rest == 0) {
+
+        ngx_http_copy_non_buffered_request_body(r);
+            
+        /* the whole request body was pre-read */
+        rb->post_handler(r);
+
+        return NGX_OK;
+    }
+
+    if (rb->rest < 0) {
+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                      "negative request body rest");
+        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        goto done;
+    }
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    size = clcf->client_body_buffer_size;
+    size += size >> 2;
+
+    if (!r->headers_in.chunked && (rb->rest < (off_t) size)) {
+        size = (ssize_t) rb->rest;
+
+        if (r->request_body_in_single_buf) {
+            size += preread;
+        }
+
+    } else {
+        size = clcf->client_body_buffer_size;
+    }
+
+    rb->buf = ngx_create_temp_buf(r->pool, size);
+    if (rb->buf == NULL) {
+        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;
+        goto done;
+    }
+
+    r->read_event_handler =
+        ngx_http_read_non_buffered_client_request_body_handler;
+    r->write_event_handler = ngx_http_request_empty_handler;
+
+    nb->buffered = 1;
+    nb->postpone_size = preread;
+
+    rc = ngx_http_do_read_non_buffered_client_request_body(r);
+
+done:
+
+    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        r->main->count--;
+    }
+
+    if (rc == NGX_AGAIN) {
+
+        if (nb->buffered) {
+            r->read_event_handler =
+                ngx_http_read_non_buffered_client_request_body_handler;
+        }
+
+    } else if (rc == NGX_OK || rc == NGX_DECLINED) {
+        rb->post_handler(r);
+    }
+
+    return rc;
+}
+
+
+static void
+ngx_http_read_non_buffered_client_request_body_handler(ngx_http_request_t *r)
+{
+    ngx_int_t  rc;
+
+    if (r->connection->read->timedout) {
+        r->connection->timedout = 1;
+        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);
+        return;
+    }
+
+    rc = ngx_http_do_read_non_buffered_client_request_body(r);
+
+    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        ngx_http_finalize_request(r, rc);
+    }
+
+    if (rc == NGX_OK || rc == NGX_DECLINED) {
+        r->request_body->post_handler(r);
+    }
+}
+
+
+ngx_int_t
+ngx_http_do_read_non_buffered_client_request_body(ngx_http_request_t *r)
+{
+    off_t                                  rest;
+    size_t                                 size;
+    ssize_t                                n;
+    ngx_int_t                              rc;
+    ngx_chain_t                            out;
+    ngx_connection_t                      *c;
+    ngx_http_request_body_t               *rb;
+    ngx_http_core_loc_conf_t              *clcf;
+    ngx_http_request_body_non_buffered_t  *nb;
+
+    c = r->connection;
+    rb = r->request_body;
+    nb = rb->non_buffered;
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http read non buffered client request body");
+
+    for ( ;; ) {
+        for ( ;; ) {
+            if (rb->buf->last == rb->buf->end) {
+
+                /* pass buffer to request body filter chain */
+
+                out.buf = rb->buf;
+                out.next = NULL;
+
+                rc = ngx_http_request_body_filter(r, &out);
+
+                if (rc != NGX_OK) {
+                    return rc;
+                }
+
+                rb->buf->pos = rb->buf->start;
+                rb->buf->last = rb->buf->start;
+
+            }
+
+            if (rb->bufs) {
+
+                /* copy to non_buffered buffers */
+
+                rc = ngx_http_copy_non_buffered_request_body(r);
+
+                if (rc == NGX_DECLINED) {
+
+                    if (nb->buffered) {
+                        goto read_ok;
+                    }
+
+                    return NGX_DECLINED;
+
+                } else if (rc == NGX_ERROR) {
+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                }
+
+                /* update chains */
+
+                rc = ngx_http_request_body_filter(r, NULL);
+
+                if (rc != NGX_OK) {
+                    return rc;
+                }
+
+                if (rb->busy != NULL) {
+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                }
+
+                ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                               "http no buffered client request body "
+                               "request_length: %O, rest: %uz, postpone_size: %O",
+                               r->request_length, rb->rest, nb->postpone_size);
+
+                if (nb->postpone_size >= (off_t) clcf->client_body_postpone_size) {
+                    nb->flush = 1;
+
+                    if (nb->buffered) {
+                        goto read_ok;
+                    }
+
+                    return NGX_DECLINED;
+                }
+            }
+
+            size = rb->buf->end - rb->buf->last;
+            rest = rb->rest - (rb->buf->last - rb->buf->pos);
+
+            if ((off_t) size > rest) {
+                size = (size_t) rest;
+            }
+
+            n = c->recv(c, rb->buf->last, size);
+
+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                           "http client non buffered request body recv %z", n);
+
+            if (n == NGX_AGAIN) {
+                break;
+            }
+
+            if (n == 0) {
+                ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                              "client prematurely closed connection");
+            }
+
+            if (n == 0 || n == NGX_ERROR) {
+                c->error = 1;
+                return NGX_HTTP_BAD_REQUEST;
+            }
+
+            rb->buf->last += n;
+            r->request_length += n;
+
+            if (n == rest) {
+                /* pass buffer to request body filter chain */
+
+                out.buf = rb->buf;
+                out.next = NULL;
+
+                rc = ngx_http_request_body_filter(r, &out);
+
+                if (rc != NGX_OK) {
+                    return rc;
+                }
+            }
+
+            if (rb->rest == 0) {
+                break;
+            }
+
+            if (rb->buf->last < rb->buf->end) {
+                break;
+            }
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "http client non buffered request body rest %O",
+                       rb->rest);
+
+        if (rb->rest == 0) {
+            break;
+        }
+
+        if (!c->read->ready) {
+            ngx_add_timer(c->read, clcf->client_body_timeout);
+
+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            return NGX_AGAIN;
+        }
+    }
+
+    if (c->read->timer_set) {
+        ngx_del_timer(c->read);
+    }
+
+    /* save the last part */
+
+    rc = ngx_http_copy_non_buffered_request_body(r);
+
+    if (rc == NGX_DECLINED) {
+        return NGX_DECLINED;
+    } else if (rc == NGX_ERROR) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+read_ok:
+
+    r->read_event_handler = ngx_http_block_reading;
+
+    nb->buffered = 0;
+
+    return NGX_OK;
+}
+
+
+/* 
+ * TODO: This the simplest way to add this patch. But it introduces
+ * memory copy. Change me.
+ */
+static ngx_int_t
+ngx_http_copy_non_buffered_request_body(ngx_http_request_t *r)
+{
+    ssize_t                               size;
+    ngx_int_t                             rc;
+    ngx_chain_t                          *cl;
+    ngx_http_request_body_t              *rb;
+    ngx_http_request_body_non_buffered_t *nb;
+
+    rb = r->request_body;
+    nb = rb->non_buffered;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "http copy client request body, non buffered bufs %p",
+                   rb->bufs);
+
+    if (rb->bufs == NULL) {
+        return NGX_OK;
+    }
+
+#if (NGX_DEBUG)
+
+    for (cl = rb->bufs; cl; cl = cl->next) {
+        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
+                       "http rb->bufs before t:%d f:%d %p, pos %p, size: %z "
+                       "file: %O, size: %z",
+                       cl->buf->temporary, cl->buf->in_file,
+                       cl->buf->start, cl->buf->pos,
+                       cl->buf->last - cl->buf->pos,
+                       cl->buf->file_pos,
+                       cl->buf->file_last - cl->buf->file_pos);
+    }
+
+#endif
+
+    for (cl = rb->bufs; cl;) {
+
+        if (ngx_buf_size(cl->buf) == 0 && !ngx_buf_special(cl->buf)) {
+            cl = cl->next;
+            continue;
+        }
+
+        if ((nb->buf == NULL) || (nb->buf->end == nb->buf->last)) {
+            rc = ngx_http_request_body_get_buf(r);
+
+            if (rc == NGX_ERROR) {
+                return NGX_ERROR;
+
+            } else if (rc == NGX_DECLINED) {
+
+                /* The buffers are full */
+                return NGX_DECLINED;
+            }
+        }
+
+        size = nb->buf->end - nb->buf->last;
+        if (size > ngx_buf_size(cl->buf)) {
+            size = ngx_buf_size(cl->buf);
+        }
+
+        if (size) {
+            ngx_memcpy(nb->buf->last, cl->buf->pos, size);
+
+            cl->buf->pos += size;
+            nb->buf->last += size;
+            nb->postpone_size += size;
+        }
+
+        if (cl->buf->pos == cl->buf->last) {
+            /* TODO: honor other tags */
+            nb->buf->last_buf = cl->buf->last_buf;
+            cl = cl->next;
+        }
+    }
+
+#if (NGX_DEBUG)
+
+    for (cl = nb->bufs; cl; cl = cl->next) {
+        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
+                       "http nb->bufs t:%d f:%d %p, pos %p, size: %z "
+                       "file: %O, size: %z",
+                       cl->buf->temporary, cl->buf->in_file,
+                       cl->buf->start, cl->buf->pos,
+                       cl->buf->last - cl->buf->pos,
+                       cl->buf->file_pos,
+                       cl->buf->file_last - cl->buf->file_pos);
+    }
+
+    for (cl = rb->bufs; cl; cl = cl->next) {
+        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,
+                       "http rb->bufs t:%d f:%d %p, pos %p, size: %z "
+                       "file: %O, size: %z",
+                       cl->buf->temporary, cl->buf->in_file,
+                       cl->buf->start, cl->buf->pos,
+                       cl->buf->last - cl->buf->pos,
+                       cl->buf->file_pos,
+                       cl->buf->file_last - cl->buf->file_pos);
+    }
+
+#endif
+
+    rb->bufs = NULL;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_request_body_get_buf(ngx_http_request_t *r)
+{
+    ngx_chain_t                           *cl;
+    ngx_http_core_loc_conf_t              *clcf;
+    ngx_http_request_body_non_buffered_t  *nb;
+
+    nb = r->request_body->non_buffered;
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (nb->free) {
+
+        cl = nb->free;
+        nb->free = nb->free->next;
+
+    } else {
+
+        if (nb->num >= clcf->client_body_buffers.num
+            && r->request_body->rest != 0) {
+
+            nb->nomem = 1;
+            return NGX_DECLINED; 
+        }
+
+        cl = ngx_alloc_chain_link(r->pool);
+        if (cl == NULL) {
+            return NGX_ERROR;
+        }
+
+        cl->buf = ngx_create_temp_buf(r->pool, clcf->client_body_buffers.size);
+        if (cl->buf == NULL) {
+            return NGX_ERROR;
+        }
+
+        cl->buf->tag =
+            (ngx_buf_tag_t) &ngx_http_do_read_non_buffered_client_request_body;
+        cl->buf->recycled = 1;
+
+        nb->num++;
+    }
+
+    cl->next = NULL;
+
+    nb->buf = cl->buf;
+    *nb->last_out = cl;
+    nb->last_out = &cl->next;
+
+    return NGX_OK;
+}
+
+
 ngx_int_t
 ngx_http_discard_request_body(ngx_http_request_t *r)
 {
Only in nginx-1.7.6vd/src/http: ngx_http_request_body.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http_upstream.c nginx-1.7.6vd/src/http/ngx_http_upstream.c
--- nginx-1.7.6/src/http/ngx_http_upstream.c	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_upstream.c	2014-10-02 17:45:48.000000000 +0200
@@ -35,8 +35,14 @@
     ngx_http_upstream_t *u);
 static void ngx_http_upstream_send_request(ngx_http_request_t *r,
     ngx_http_upstream_t *u);
+static ngx_int_t ngx_http_upstream_output_filter_init(void *data);
+static ngx_int_t ngx_http_upstream_output_filter(void *data,
+    ngx_chain_t *in);
 static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r,
     ngx_http_upstream_t *u);
+static void ngx_http_upstream_send_non_buffered_request(ngx_http_request_t *r,
+    ngx_http_upstream_t *u);
+static void ngx_http_upstream_read_non_buffered_request(ngx_http_request_t *r);
 static void ngx_http_upstream_process_header(ngx_http_request_t *r,
     ngx_http_upstream_t *u);
 static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r,
@@ -543,6 +549,18 @@
         u->request_bufs = r->request_body->bufs;
     }
 
+    if (!u->output_filter) {
+        u->output_filter_init = ngx_http_upstream_output_filter_init;
+        u->output_filter = ngx_http_upstream_output_filter;
+        u->output_filter_ctx = r;
+    }
+
+    if (u->output_filter_init && u->output_filter_init(u->output_filter_ctx)
+       != NGX_OK) {
+        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return;
+    }
+
     if (u->create_request(r) != NGX_OK) {
         ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
         return;
@@ -1307,6 +1325,17 @@
     u->writer.limit = 0;
 
     if (u->request_sent) {
+
+        /*
+         * no buffering request can't reuse the request body when part of
+         * the body has been sent.
+         */
+        if (!r->request_buffering) {
+            ngx_http_upstream_finalize_request(r, u,
+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
         if (ngx_http_upstream_reinit(r, u) != NGX_OK) {
             ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1356,6 +1385,11 @@
 
 #endif
 
+    if (!r->request_buffering) {
+        ngx_http_upstream_send_non_buffered_request(r, u);
+        return;
+    }
+
     ngx_http_upstream_send_request(r, u);
 }
 
@@ -1458,6 +1492,11 @@
 
         c = r->connection;
 
+        if (!r->request_buffering) {
+            ngx_http_upstream_send_non_buffered_request(r, u);
+            return;
+        }
+
         ngx_http_upstream_send_request(r, u);
 
         ngx_http_run_posted_requests(c);
@@ -1718,6 +1757,286 @@
 }
 
 
+static ngx_int_t
+ngx_http_upstream_output_filter_init(void *data)
+{
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_upstream_output_filter(void *data, ngx_chain_t *in)
+{
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_upstream_send_non_buffered_request(ngx_http_request_t *r,
+    ngx_http_upstream_t *u)
+{
+    int                                   tcp_nodelay;
+    ngx_int_t                             rc;
+    ngx_connection_t                     *c;
+    ngx_http_request_body_t              *rb;
+    ngx_http_core_loc_conf_t             *clcf;
+    ngx_http_request_body_non_buffered_t *nb;
+
+    c = u->peer.connection;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "http upstream read/send no buffered request");
+
+    if (!u->request_sent && ngx_http_upstream_test_connect(c) != NGX_OK) {
+        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);
+        return;
+    }
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (clcf->tcp_nodelay && c->tcp_nodelay == NGX_TCP_NODELAY_UNSET) {
+
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "upstream tcp_nodelay");
+
+        tcp_nodelay = 1;
+
+        if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,
+                       (const void *) &tcp_nodelay, sizeof(int)) == -1) {
+
+            ngx_connection_error(c, ngx_socket_errno,
+                                 "setsockopt(TCP_NODELAY) failed");
+            ngx_http_upstream_finalize_request(r, u, 0);
+            return;
+        }
+
+        c->tcp_nodelay = NGX_TCP_NODELAY_SET;
+    }
+
+    rb = r->request_body;
+
+    for ( ;; ) {
+
+        if (rb == NULL) {
+
+            c->log->action = "sending no buffered request to upstream";
+
+            rc = ngx_output_chain(&u->output,
+                                  u->request_sent ? NULL : u->request_bufs);
+
+            goto send_done;
+        }
+
+        nb = rb->non_buffered;
+
+        if (u->request_sent && rb->rest) {
+            c->log->action = "reading no buffered request body from client";
+
+            rc = ngx_http_do_read_non_buffered_client_request_body(r);
+
+            if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+                ngx_http_upstream_finalize_request(r, u, rc);
+                return;
+            }
+
+            if (!(nb->busy || nb->flush || nb->nomem || rb->rest == 0)) {
+
+                if (c->write->timer_set) {
+                    ngx_del_timer(c->write);
+                }
+
+                /* 
+                 * the read timer has been added in the above
+                 * ngx_http_do_read_non_buffered_client_request_body()
+                 * function
+                 */
+
+                r->read_event_handler =
+                    ngx_http_upstream_read_non_buffered_request;
+
+                if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {
+                    ngx_http_upstream_finalize_request(r, u,
+                                           NGX_HTTP_INTERNAL_SERVER_ERROR);
+                }
+
+                return;
+            }
+        }
+
+        c->log->action = "sending no buffered request to upstream";
+
+#if (NGX_DEBUG)
+        ngx_buf_t   *buf;
+        ngx_chain_t *cl;
+
+        for (cl = u->request_bufs; cl; cl = cl->next) {
+            buf = cl->buf;
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                          "http upstream before out bufs: p=%p, s=%d, size=%uO",
+                          buf, ngx_buf_special(buf), ngx_buf_size(buf));
+        }
+
+        for (cl = nb->bufs; cl; cl = cl->next) {
+            buf = cl->buf;
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                          "http upstream before nb->bufs: p=%p, s=%d, size=%uO",
+                          buf, ngx_buf_special(buf), ngx_buf_size(buf));
+        }
+
+#endif
+        
+        /* copy buffers from nb->bufs to u->request_bufs */
+        if (u->output_filter(u->output_filter_ctx, nb->bufs) != NGX_OK) {
+            ngx_http_upstream_finalize_request(r, u,
+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
+
+            return;
+        }
+
+        rc = ngx_output_chain(&u->output, u->request_bufs);
+
+        /* Flush the buffer for sure. It may be stucked in the SSL buffer. */
+        if (rc == NGX_AGAIN && c->buffered) {
+            rc = ngx_output_chain(&u->output, NULL);
+        }
+
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "http upstream send no buffered request: rc=%i", rc);
+
+        ngx_chain_update_chains(r->pool, &nb->free, &nb->busy, &u->request_bufs,
+            (ngx_buf_tag_t) &ngx_http_do_read_non_buffered_client_request_body);
+
+#if (NGX_DEBUG)
+        for (cl = nb->busy; cl; cl = cl->next) {
+            buf = cl->buf;
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                           "http upstream send busy bufs: p=%p, s=%d, size=%uO",
+                           buf, ngx_buf_special(buf), ngx_buf_size(buf));
+        }
+
+        for (cl = nb->free; cl; cl = cl->next) {
+            buf = cl->buf;
+            ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                           "http upstream send free bufs: p=%p, s=%d, size=%uO",
+                           buf, ngx_buf_special(buf), ngx_buf_size(buf));
+        }
+#endif
+
+        nb->bufs = NULL;
+        nb->buf = NULL;
+        nb->last_out = &nb->bufs;
+        nb->postpone_size = 0;
+        nb->nomem = 0;
+        nb->flush = 0;
+        u->request_bufs = NULL;
+
+send_done:
+
+        u->request_sent = 1;
+
+        if (rc == NGX_ERROR) {
+
+            ngx_http_upstream_finalize_request(r, u,
+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
+
+            return;
+        }
+
+        if (r->connection->read->timer_set) {
+            ngx_del_timer(r->connection->read);
+        }
+
+        if (c->write->timer_set) {
+            ngx_del_timer(c->write);
+        }
+
+        if (rc == NGX_AGAIN) {
+            ngx_add_timer(c->write, u->conf->send_timeout);
+
+            if (ngx_handle_write_event(c->write, u->conf->send_lowat)
+                != NGX_OK) {
+                ngx_http_upstream_finalize_request(r, u,
+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
+                return;
+            }
+
+            return;
+        }
+
+        /* rc == NGX_OK */
+
+        if (rb == NULL || rb->rest == 0) {
+            break;
+        }
+    }
+
+    /* send all the request body */
+
+    if (!u->store && !r->post_action && !u->conf->ignore_client_abort) {
+        r->read_event_handler = ngx_http_upstream_rd_check_broken_connection;
+    }
+
+    if (c->tcp_nopush == NGX_TCP_NOPUSH_SET) {
+        if (ngx_tcp_push(c->fd) == NGX_ERROR) {
+            ngx_log_error(NGX_LOG_CRIT, c->log, ngx_socket_errno,
+                          ngx_tcp_push_n " failed");
+            ngx_http_upstream_finalize_request(r, u,
+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);
+            return;
+        }
+
+        c->tcp_nopush = NGX_TCP_NOPUSH_UNSET;
+    }
+
+    ngx_add_timer(c->read, u->conf->read_timeout);
+
+#if 1
+    if (c->read->ready) {
+
+        /* post aio operation */
+
+        /*
+         * TODO comment
+         * although we can post aio operation just in the end
+         * of ngx_http_upstream_connect() CHECK IT !!!
+         * it's better to do here because we postpone header buffer allocation
+         */
+
+        ngx_http_upstream_process_header(r, u);
+        return;
+    }
+#endif
+
+    u->write_event_handler = ngx_http_upstream_dummy_handler;
+
+    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+        ngx_http_upstream_finalize_request(r, u,
+                                           NGX_HTTP_INTERNAL_SERVER_ERROR);
+        return;
+    }
+}
+
+
+static void
+ngx_http_upstream_read_non_buffered_request(ngx_http_request_t *r)
+{
+    ngx_connection_t     *c;
+    ngx_http_upstream_t  *u;
+
+    c = r->connection;
+    u = r->upstream;
+
+    if (c->read->timedout) {
+        c->timedout = 1;
+        ngx_connection_error(c, NGX_ETIMEDOUT, "client timed out");
+        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);
+        return;
+    }
+
+    ngx_http_upstream_send_non_buffered_request(r, u);
+}
+
+
 static void
 ngx_http_upstream_send_request_handler(ngx_http_request_t *r,
     ngx_http_upstream_t *u)
@@ -1751,6 +2070,11 @@
         return;
     }
 
+    if (!r->request_buffering) {
+        ngx_http_upstream_send_non_buffered_request(r, u);
+        return;
+    }
+
     ngx_http_upstream_send_request(r, u);
 }
 
Only in nginx-1.7.6vd/src/http: ngx_http_upstream.c.orig
diff -ru nginx-1.7.6/src/http/ngx_http_upstream.h nginx-1.7.6vd/src/http/ngx_http_upstream.h
--- nginx-1.7.6/src/http/ngx_http_upstream.h	2014-09-30 15:20:34.000000000 +0200
+++ nginx-1.7.6vd/src/http/ngx_http_upstream.h	2014-10-02 18:27:10.000000000 +0200
@@ -155,6 +155,7 @@
     ngx_uint_t                       next_upstream;
     ngx_uint_t                       store_access;
     ngx_uint_t                       next_upstream_tries;
+    ngx_flag_t                       request_buffering;
     ngx_flag_t                       buffering;
     ngx_flag_t                       pass_request_headers;
     ngx_flag_t                       pass_request_body;
@@ -306,6 +307,12 @@
     ngx_chain_t                     *busy_bufs;
     ngx_chain_t                     *free_bufs;
 
+    /* Nginx => Upstream */
+    ngx_int_t                      (*output_filter_init)(void *data);
+    ngx_int_t                      (*output_filter)(void *data, ngx_chain_t *in);
+    void                            *output_filter_ctx;
+
+
     ngx_int_t                      (*input_filter_init)(void *data);
     ngx_int_t                      (*input_filter)(void *data, ssize_t bytes);
     void                            *input_filter_ctx;
Only in nginx-1.7.6vd/src/http: ngx_http_upstream.h.orig
